[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;","type":"same"},{"content":"use std::path::Path;","type":"add"},{"content":"\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n\n    let out_dir = format!(\"outfiles/{}\", Utc::now());\n    fs::create_dir(&out_dir)?;\n    let changes_filename = format!(\"{}/changes.json\", out_dir);\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = format!(\"{}/main.rs\", out_dir);\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}\n","type":"same"},{"content":"\nfn watch_file(path: &Path) {\n\n}","type":"add"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::Path;\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n\n    let out_dir = format!(\"outfiles/{}\", Utc::now());\n    fs::create_dir(&out_dir)?;\n    let changes_filename = format!(\"{}/changes.json\", out_dir);\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = format!(\"{}/main.rs\", out_dir);\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}\n\n\nfn watch_file(path: &Path) {","type":"same"},{"content":"","type":"remove"},{"content":"    ","type":"add"},{"content":"}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::Path;\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {","type":"same"},{"content":"\n}\n\n\nfn watch_file(path: &Path) {","type":"add"},{"content":"    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n\n    let out_dir = format!(\"outfiles/{}\", Utc::now());\n    fs::create_dir(&out_dir)?;\n    let changes_filename = format!(\"{}/changes.json\", out_dir);\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = format!(\"{}/main.rs\", out_dir);\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"},{"content":"\n\nfn watch_file(path: &Path) {\n    \n}","type":"remove"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::Path;\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));","type":"same"},{"content":"    let mut previous_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");","type":"remove"},{"content":"    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");","type":"add"},{"content":"\n    let out_dir = format!(\"outfiles/{}\", Utc::now());\n    fs::create_dir(&out_dir)?;\n    let changes_filename = format!(\"{}/changes.json\", out_dir);\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = format!(\"{}/main.rs\", out_dir);\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::Path;\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = format!(\"outfiles/{}\", Utc::now());\n    fs::create_dir(&out_dir)?;\n    let changes_filename = format!(\"{}/changes.json\", out_dir);\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();","type":"same"},{"content":"    let original_filename = format!(\"{}/main.rs\", out_dir);","type":"remove"},{"content":"    let original_filename = format!(\"{}/{}\", out_dir);","type":"add"},{"content":"    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::Path;\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = format!(\"outfiles/{}\", Utc::now());\n    fs::create_dir(&out_dir)?;\n    let changes_filename = format!(\"{}/changes.json\", out_dir);\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();","type":"same"},{"content":"    let original_filename = format!(\"{}/{}\", out_dir);","type":"remove"},{"content":"    let original_filename = ;","type":"add"},{"content":"    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;","type":"same"},{"content":"use std::path::Path;","type":"remove"},{"content":"use std::path::{Path, PathBuf};","type":"add"},{"content":"\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n","type":"same"},{"content":"    let out_dir = format!(\"outfiles/{}\", Utc::now());","type":"remove"},{"content":"    let out_dir = {\n        let mut buf = PathBuf::new(\"outfiles\");\n        buf.push(Utc::now())\n    }","type":"add"},{"content":"    fs::create_dir(&out_dir)?;\n    let changes_filename = format!(\"{}/changes.json\", out_dir);\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = ;\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = {\n        let mut buf = PathBuf::new(\"outfiles\");","type":"same"},{"content":"        buf.push(Utc::now())\n    }","type":"remove"},{"content":"        buf.push(Utc::now());\n        buf\n    };","type":"add"},{"content":"    fs::create_dir(&out_dir)?;\n    let changes_filename = format!(\"{}/changes.json\", out_dir);\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = ;\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = {","type":"same"},{"content":"        let mut buf = PathBuf::new(\"outfiles\");","type":"remove"},{"content":"        let mut buf = PathBuf::new();\n        buf.push(\"outfiles\");","type":"add"},{"content":"        buf.push(Utc::now());\n        buf\n    };\n    fs::create_dir(&out_dir)?;\n    let changes_filename = format!(\"{}/changes.json\", out_dir);\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = ;\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = {\n        let mut buf = PathBuf::new();\n        buf.push(\"outfiles\");\n        buf.push(Utc::now());\n        buf\n    };\n    fs::create_dir(&out_dir)?;","type":"same"},{"content":"    let changes_filename = format!(\"{}/changes.json\", out_dir);","type":"remove"},{"content":"    let changes_filename =","type":"add"},{"content":"    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = ;\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n","type":"same"},{"content":"    let out_dir = {\n        let mut buf = PathBuf::new();\n        buf.push(\"outfiles\");\n        buf.push(Utc::now());\n        buf\n    };","type":"remove"},{"content":"    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()))","type":"add"},{"content":"    fs::create_dir(&out_dir)?;\n    let changes_filename =\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = ;\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n","type":"same"},{"content":"    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()))","type":"remove"},{"content":"    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));","type":"add"},{"content":"    fs::create_dir(&out_dir)?;\n    let changes_filename =\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = ;\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;","type":"same"},{"content":"    let changes_filename =","type":"remove"},{"content":"    let changes_filename = Path","type":"add"},{"content":"    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = ;\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;","type":"same"},{"content":"    let changes_filename = Path","type":"remove"},{"content":"    let changes_filename = ","type":"add"},{"content":"    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = ;\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;","type":"same"},{"content":"    let changes_filename = ","type":"remove"},{"content":"    let changes_filename = out_dir.to_path_buf()","type":"add"},{"content":"    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = ;\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;","type":"same"},{"content":"    let changes_filename = out_dir.to_path_buf()","type":"remove"},{"content":"    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");","type":"add"},{"content":"    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = ;\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();","type":"same"},{"content":"    let original_filename = ;","type":"remove"},{"content":"    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());","type":"add"},{"content":"    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {","type":"same"},{"content":"","type":"remove"},{"content":"    watch_file(\"src/main.rs\");\n    watch_file(\"Cargo.toml\");","type":"add"},{"content":"}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    watch_file(\"src/main.rs\");\n    watch_file(\"Cargo.toml\");","type":"same"},{"content":"    Ok(())","type":"add"},{"content":"}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {","type":"same"},{"content":"    watch_file(\"src/main.rs\");\n    watch_file(\"Cargo.toml\");","type":"remove"},{"content":"    watch_file(\"src/main.rs\")?;\n    watch_file(\"Cargo.toml\")?;","type":"add"},{"content":"    Ok(())\n}\n\n\nfn watch_file(path: &Path) {\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    watch_file(\"src/main.rs\")?;\n    watch_file(\"Cargo.toml\")?;\n    Ok(())\n}\n\n","type":"same"},{"content":"fn watch_file(path: &Path) {","type":"remove"},{"content":"fn watch_file(path: &Path) -> Result<(), io::Error>{","type":"add"},{"content":"    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {","type":"same"},{"content":"    watch_file(\"src/main.rs\")?;\n    watch_file(\"Cargo.toml\")?;","type":"remove"},{"content":"    watch_file(\"src/main.rs\".into())?;\n    watch_file(\"Cargo.toml\".into())?;","type":"add"},{"content":"    Ok(())\n}\n\n\nfn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    watch_file(\"src/main.rs\".into())?;\n    watch_file(\"Cargo.toml\".into())?;\n    Ok(())\n}\n\n","type":"same"},{"content":"fn watch_file(path: &Path) -> Result<(), io::Error>{","type":"remove"},{"content":"async fn watch_file(path: &Path) -> Result<(), io::Error>{","type":"add"},{"content":"    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {","type":"same"},{"content":"    watch_file(\"src/main.rs\".into())?;\n    watch_file(\"Cargo.toml\".into())?;","type":"remove"},{"content":"    watch_file(\"src/main.rs\".into()).await?;\n    watch_file(\"Cargo.toml\".into()).await?;","type":"add"},{"content":"    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {","type":"same"},{"content":"    watch_file(\"src/main.rs\".into()).await?;\n    watch_file(\"Cargo.toml\".into()).await?;","type":"remove"},{"content":"    watch_file(\"src/main.rs\".into())?;\n    watch_file(\"Cargo.toml\".into())?;","type":"add"},{"content":"    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {","type":"same"},{"content":"    watch_file(\"src/main.rs\".into())?;","type":"remove"},{"content":"    watch_file(\"src/main.rs\".into());","type":"add"},{"content":"    watch_file(\"Cargo.toml\".into())?;\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {","type":"same"},{"content":"    watch_file(\"src/main.rs\".into());\n    watch_file(\"Cargo.toml\".into())?;","type":"remove"},{"content":"    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);","type":"add"},{"content":"    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;","type":"same"},{"content":"use futures::join","type":"add"},{"content":"use std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;","type":"same"},{"content":"use futures::join","type":"remove"},{"content":"use futures::join;","type":"add"},{"content":"use std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;","type":"same"},{"content":"use futures::join;","type":"remove"},{"content":"use futures::try_join;","type":"add"},{"content":"use std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;","type":"same"},{"content":"use futures::try_join;","type":"remove"},{"content":"use tokio::try","type":"add"},{"content":"use std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;","type":"same"},{"content":"use tokio::try","type":"remove"},{"content":"use tokio::macros::try_join;","type":"add"},{"content":"use std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;","type":"same"},{"content":"use tokio::macros::try_join;","type":"remove"},{"content":"use tokio::try_join;","type":"add"},{"content":"use std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse tokio::try_join;\nuse std::path::{Path, PathBuf};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n","type":"same"},{"content":"    let out_dir = Path::new(format!(\"outfiles/{}\", Utc::now()));","type":"remove"},{"content":"    let out_dir = Path::new(&format!(\"outfiles/{}\", Utc::now()));","type":"add"},{"content":"    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse tokio::try_join;","type":"same"},{"content":"use std::path::{Path, PathBuf};","type":"remove"},{"content":"use std::path::{Path};","type":"add"},{"content":"\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(&format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;\n    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse tokio::try_join;\nuse std::path::{Path};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_dir = Path::new(&format!(\"outfiles/{}\", Utc::now()));\n    fs::create_dir(&out_dir)?;","type":"same"},{"content":"    let changes_filename = out_dir.to_path_buf().push(\"changes.json\");","type":"remove"},{"content":"    let changes_filename = {\n        let mut buf = out_dir.to_path_buf();\n        buf.push(\"changes.json\");\n        buf\n    };","type":"add"},{"content":"    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();","type":"same"},{"content":"    let original_filename = out_dir.to_path_buf().push(path.file_name().unwrap());","type":"remove"},{"content":"    let original_filename = {\n        let mut buf = out_dir.to_path_buf();\n        buf.push(path.file_name().unwrap());\n        buf\n    };","type":"add"},{"content":"    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse tokio::try_join;\nuse std::path::{Path};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(\"src/main.rs\".into());\n    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n","type":"same"},{"content":"    let out_dir = Path::new(&format!(\"outfiles/{}\", Utc::now()));","type":"remove"},{"content":"    let out_path = format!(\"outfiles/{}\", Utc::now());\n    let out_dir = Path::new(&out_path);","type":"add"},{"content":"    fs::create_dir(&out_dir)?;\n    let changes_filename = {\n        let mut buf = out_dir.to_path_buf();\n        buf.push(\"changes.json\");\n        buf\n    };\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = {\n        let mut buf = out_dir.to_path_buf();\n        buf.push(path.file_name().unwrap());\n        buf\n    };\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse tokio::try_join;\nuse std::path::{Path};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {","type":"same"},{"content":"    let future1 = watch_file(\"src/main.rs\".into());","type":"remove"},{"content":"    let future1 = watch_file(Path::new(\"src/main.rs\"));","type":"add"},{"content":"    let future2 = watch_file(\"Cargo.toml\".into());\n    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_path = format!(\"outfiles/{}\", Utc::now());\n    let out_dir = Path::new(&out_path);\n    fs::create_dir(&out_dir)?;\n    let changes_filename = {\n        let mut buf = out_dir.to_path_buf();\n        buf.push(\"changes.json\");\n        buf\n    };\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = {\n        let mut buf = out_dir.to_path_buf();\n        buf.push(path.file_name().unwrap());\n        buf\n    };\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse tokio::try_join;\nuse std::path::{Path};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(Path::new(\"src/main.rs\"));","type":"same"},{"content":"    let future2 = watch_file(\"Cargo.toml\".into());","type":"remove"},{"content":"    let future2 = watch_file(Path::new(\"Cargo.toml\"));","type":"add"},{"content":"    try_join!(future1, future2);\n    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_path = format!(\"outfiles/{}\", Utc::now());\n    let out_dir = Path::new(&out_path);\n    fs::create_dir(&out_dir)?;\n    let changes_filename = {\n        let mut buf = out_dir.to_path_buf();\n        buf.push(\"changes.json\");\n        buf\n    };\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = {\n        let mut buf = out_dir.to_path_buf();\n        buf.push(path.file_name().unwrap());\n        buf\n    };\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
[{"content":"extern crate chrono;\nextern crate difference;\nextern crate serde_json;\nextern crate tokio;\n\nuse chrono::Utc;\nuse difference::{Changeset, Difference};\nuse serde_json::json;\nuse std::{fs, io};\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::time::Duration;\nuse tokio::time;\nuse tokio::try_join;\nuse std::path::{Path};\n\nfn diffs_to_json(diffs: &Vec<Difference>) -> String {\n    let mut values = Vec::new();\n    for diff in diffs {\n        let (type_, content) = match diff {\n            Difference::Add(c) => (\"add\", c),\n            Difference::Rem(c) => (\"remove\", c),\n            Difference::Same(c) => (\"same\", c),\n        };\n        let val = json!({\n           \"type\": type_,\n           \"content\": content\n        });\n        values.push(val.to_string());\n    }\n    format!(\"[{}]\", values.join(\",\"))\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), io::Error> {\n    let future1 = watch_file(Path::new(\"src/main.rs\"));\n    let future2 = watch_file(Path::new(\"Cargo.toml\"));","type":"same"},{"content":"    try_join!(future1, future2);","type":"remove"},{"content":"    try_join!(future1, future2)?;","type":"add"},{"content":"    Ok(())\n}\n\n\nasync fn watch_file(path: &Path) -> Result<(), io::Error>{\n    let mut interval = time::interval(Duration::from_millis(1000));\n    let mut previous_contents = fs::read_to_string(path).expect(\"Something went wrong\");\n\n    let out_path = format!(\"outfiles/{}\", Utc::now());\n    let out_dir = Path::new(&out_path);\n    fs::create_dir(&out_dir)?;\n    let changes_filename = {\n        let mut buf = out_dir.to_path_buf();\n        buf.push(\"changes.json\");\n        buf\n    };\n    let mut changes_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(changes_filename)\n        .unwrap();\n    let original_filename = {\n        let mut buf = out_dir.to_path_buf();\n        buf.push(path.file_name().unwrap());\n        buf\n    };\n    let mut original_file = OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(original_filename)\n        .unwrap();\n\n    original_file.write_all(previous_contents.as_bytes())?;\n\n    loop {\n        interval.tick().await;\n        let current_contents = fs::read_to_string(\"src/main.rs\").expect(\"Something went wrong\");\n        let changeset = Changeset::new(&previous_contents, &current_contents, \"\\n\");\n        if changeset.distance > 0 {\n            writeln!(changes_file, \"{}\", diffs_to_json(&changeset.diffs))?;\n        }\n        previous_contents = current_contents;\n    }\n}","type":"same"}]
